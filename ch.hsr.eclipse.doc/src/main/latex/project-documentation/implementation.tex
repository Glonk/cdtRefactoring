\chapter{Implementation and Solution}
\thispagestyle{fancy}

From the three specified refactorings, \textit{Toggle Function Definition} has 
been implemented in depth. This chapter explains how the refactoring was 
implemented and which problems had to be solved during development.

\section{Implementation approach}

At the beginning, as many cases as possible were collected on the project wiki 
to gain a view on what had to be realized, what was planned to take into scope 
and what had nothing to do with toggling function definitions. Some cases were 
simple, some exotic. The simplest one, toggling from inside a class to the same 
file outside the class, was chosen to be implemented first (See listings 
\ref{funcdefPre} and \ref{funcdefPost}). 

Before, a skeleton plug-in was built with a \texttt{NullRefactoring} to try
whether it was possible to develop a separate plug-in instead of directly
manipulating the CDT source code. By this approach it was assured that the
developed plug-in may be deployed easily even without being integrated into CDT.

After the first refactoring was implemented, more cases were added by order how
a member function is toggled circularly.

\section{Architecture}

In Eclipse, most of the architecture of a plug-in is already given. Some
specialties of the toggle refactoring implementation are presented in this
section.

\subsection{Strategies}

The way to toggle from one place to another differs a lot depending on
the current position. Having all logic in the same unit would need a complex
conditional structure which is on one side confusing and on the other side
slow.

Consequently, a strategy pattern based code structure was introduced. For
toggling a simple not templated member function, three strategies were used.
With the help of these, member functions may be toggled circularly.

\begin{itemize}
\item ToggleFromClassToInHeaderStrategy
\item ToggleFromInHeaderToImplementationStrategy
\item ToggleFromImplementationHeaderOrClassStrategy
\end{itemize}

To support templated classes, another strategy is required which toggles from
\textit{in-header} back to \textit{in-class} as explained in section
\ref{templatedmember}. This strategy is specially implemented to support
templated functions.

\begin{itemize}
\item ToggleFromInHeaderToClassStrategy
\end{itemize}

All these strategies implement an interface with a \texttt{run()} method taking
a \texttt{ModificationCollector} to collect the changes to be applied to the 
source code.

\begin{lstlisting}[caption={IToggleRefactoringStrategy},
label={01templatedMember}, language=Java]
public interface IToggleRefactoringStrategy {
  public void run(ModificationCollector col);
}
\end{lstlisting}

An interface was chosen because an abstract class containing all the methods
needed by the various strategies was too big and unclear. This resulted in the
interface and a static helper class, named \texttt{ToggleNodeHelper}.

\subsection{ToggleNodeHelper}

\texttt{ToggleNodeHelper} contains a lot of methods which could be reused by
other projects. It inherits from NodeHelper to make the integration of these
methods as smooth as possible.

\subsection{Context}

The \texttt{ToggleRefactoringContext} is used to collect and store information 
about definitions, declarations and their corresponding translation units.

The context is passed then passed to the strategy factory. See \ref{factory}.
The factory passes the context to the, by itself created strategy since the
strategy is the main user of the context and retrieves all its information it.

The context was introduced to prevent the code smell \textit{Too Many 
Parameters}\cite{cwiki}. A common refactoring for this problem is to introduce a 
parameter object which consolidates all arguments.

The justification that the context searches the information by its own is due
to the fact that context would just be a very small data class and yet another
class would be needed to search and collect the information which builds and
returns the context.

\subsection{Strategy Factory}
\label{factory}

The \textit{ToggleStrategyFactory} is used to decide which strategy should be 
considered, based on the context given. The strategy makes varous checks
and decides which strategy will be returned.

\begin{lstlisting}[caption={IToggleRefactoringStrategy},
label={strategy}, language=Java]

public IToggleRefactoringStrategy getStategy() {
  if (context.getDefinition() == null) {
    throw new NotSupportedException(...
  }
  ...
  if (isInClassSituation()) {
    return new ClassToInHeaderStrategy(context);
  }
  if (isTemplateSituation()) {
    return new HeaderToClassStrategy(context);
  }
  ...
}
\end{lstlisting}

\subsection{Class Diagram}
\begin{figure}[h]
  \centering
  \includegraphics[width=0.9\textwidth]{images/class_diagram.png}
  \caption{class diagram of Toggle Function Definition}
  \label{classdiagram}
\end{figure}

\subsection{Basic Call Flow}
The sequence diagram in figure \ref{sd} illustrates the basic call flow when 
\textit{Toggle Function} is invoked.
\begin{figure}[h]
  \centering
  \includegraphics[width=0.9\textwidth]{images/sequence_diagram.png}
  \caption{Basic call flow when toggling a function definition}
  \label{sd}
\end{figure}

\subsection{Implications of not using a refactoring wizard}
No wizard was used for this refactoring since it must be fast and may be 
executed several times in succession. When using a wizard, the 
\textit{RefactoringWizardOpenOperation} handles the execution of the refactoring 
inside a separate job. Since the toggle refactoring does not use the wizard, a 
separate job had to be scheduled by the ActionDelegate.

In addition, the undo functionality had to be implemented separately. When the 
changes are performed, they (surprisingly) also return the undo changes that are 
needed by the UndoManager. The functionality of the 
\texttt{ToggleRefactoringRunner} is described in the following section.

\subsection{Running the refactoring}\label{runnersec}
The \texttt{ToggleRefactoringRunner} is instantiated and run by the 
\texttt{Tog- glingActionDelegate}. It is responsible for running the refactoring 
in a separate job and for allowing only one toggling refactoring instance being
active. The job that is scheduled belongs to the family
\texttt{FAMILY\_TOGGLE\_DEFINITION}. This is need to check weather there is
only one instance.

Listing \ref{runner} shows the simplified process without error checking. The 
changes are collected, executed and registered at the undo manager.

\begin{lstlisting}[caption={running the refactoring},label={runner},language=java]
status = refactoring.checkAllConditions(monitor);
change = refactoring.createChange(monitor);
change.initializeValidationData(monitor);

IUndoManager undoManager = 
    RefactoringCore.getUndoManager();
undoManager.aboutToPerformChange(change);
undoChange = change.perform(monitor);

undoChange.initializeValidationData(monitor);
undoManager.changePerformed(change, success);
undoManager.addUndo("toggling", undoChange);
\end{lstlisting}

\section{Testing and performance environment}

This section introduces strategies to simplify testing and monitoring of 
performance.

\subsection{A real world test environment}
The COAST~\cite{COAST} source code was used as test environment for real-world 
tests as it uses a lot of C++ code features to test the toggling.

\subsection[Fuzzy whitespace recognition for the tests]{Fuzzy whitespace 
recognition for the test environment}

As described in past theses at HSR, the refactoring testing environment
needed an exact definition of the generated code. This was annoying because
same-looking code samples could result in a red bar if white spaces were not the
same. To make writing new tests easier, the comparison method was overridden to
support fuzzy whitespace recognition.

Leading tabs or whitespaces are recognized and it is assumed that the same
indention is used for the whole file. In addition, trailing superfluous newlines
that are
added by the ASTRewriter are ignored.

The changes made to the CDT test environment helped writing new tests without
having to care whether the ASTRewriter uses spaces or tabs for indention.
Resulting code that looks the same now gives a positive test result.

\subsection{Testing issues}

The whitespace issue was already discussed. Another issue is that the Doxygen 
syntax //! may not be used in the test files since this syntax is used to 
specify the test name.

\subsubsection{Resource '/RegressionTestProject/A.h' does not exist.}

The following issue was not resolved to its cause and is still active when the 
tests are being run.

\begin{lstlisting}[caption={Randomly appearing error message},language=java]
!ENTRY org.eclipse.cdt.core 4 0 2010-12-13 ...
!MESSAGE Error: Resource '/RegressionTestProject/\
A.h' does not exist.
!STACK 1
org.eclipse.core.internal.resources.\
ResourceException: Resource '/RegressionTest\
Project/A.h' does not exist.
  at...ces.Resource.checkExists(Resource.java:326)
  [...]
\end{lstlisting}

Tests still pass without failure. During the semester thesis there was no deeper
investigation done to this problem because it seemed this is no root of a
problem. However it should be mentioned here.

\subsubsection{Testing for exceptions}

Error testing is not actually an issue but the mechanism to test for exceptions 
is not obvious, so an example will be shown at this point. 

The .rts test file may include the following syntax:

\begin{lstlisting}[caption={Syntax to set variables inside a .rts file},
language=java]
//@.config
fatalerror=true
\end{lstlisting}

The \textit{fatalerror} variable may be retrieved using a member function of \textit{RefactoringTest}:
\begin{lstlisting}[caption={Accessing a property set in the .rts file},
language=java]
@Override
protected void configureRefactoring(
    Properties refactoringProperties) {
  fatalError = Boolean.valueOf(
      refactoringProperties.getProperty(
      "fatalerror", "false")).booleanValue();
}
\end{lstlisting}

The \textit{runTest} method may then assert that an error has occurred by using:
\begin{lstlisting}[caption={Checking for errors inside the refactoring test class},language=java]
RefactoringStatus initialConditions = 
    refactoring.checkInitialConditions(
    NULL_PROGRESS_MONITOR);
if (fatalError)
  assertConditionsFatalError(initialConditions);
\end{lstlisting}

All in all, the special refactoring test environment developed by \cite{GB06} 
was a big help for refactoring relaxedly.

\subsection{Performance tests}

The simplest way to assess the speed of the refactoring is to look at the jUnit 
time measurements. The first test that is run takes more time and represents the 
time needed for first time toggling when the refactoring infrastructure has to 
be loaded. 

All performance tests must be executed on the same developer machine, taking the 
average time of three consecutive runs of all tests. Five scenarios have been 
chosen to be able to observe the performance of the toggle refactoring:

\begin{enumerate}
\item First time toggling: Includes loading of the infrastructure and will take 
some more time.
\item Toggle from in class to header: Only one file is affected by this 
refactoring. This represents the least complex refactoring and should be the 
quickest one beside the reference test.
\item Toggle from implementation to header: Two files are affected here.
\item Emtpy reference test: A dummy refactoring that won't load and analyze any 
code. Shows what amount of time is consumed by the given refactoring 
infrastructure.
\end{enumerate}

Another technique to measure time more accurately was checked out. For this, the 
\textit{org.eclipse.test.performance} plug-in was used. 


