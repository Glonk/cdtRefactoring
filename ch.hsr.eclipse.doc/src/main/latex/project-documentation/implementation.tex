\chapter{Implementation and Solution}
\thispagestyle{fancy}

\section{Architecture}

In Eclipse, most of the architecture is already given. Some specialities of the 
toggle refactoring are presented in this section.

\subsubsection{Basic call flow}
Here's the place for some nice diagram to visualize the work.

Activator -- ActionDelegate -- (Job) -- ToggleRefactoring -- Strategy

\subsubsection{The strategies}
The \textit{ToggleStrategyFactory} is used to decide which strategy should be 
considered, based on the user selection. The following strategies have been 
implemented to cover the specified cases:

\begin{itemize}
\item ToggleFromImplementationToClassStrategy
\item ToggleFreeFunctionFromInHeaderToImpl
\item ToggleFromClassToInHeaderStrategy
\item ToggleFromInHeaderToClassStrategy
\item ToggleFromInHeaderToImplementationStrategy
\end{itemize}

\subsubsection{implications of not using a refactoring wizard}
No wizard was used for this refactoring since it must be fast and may be 
executed several times in succession. When using a wizard, the 
\textit{RefactoringWizardOpenOperation} handles the execution of the refactoring 
inside a separate job. Since the toggle refactoring does not use the wizard, a 
separate job had to be scheduled by the ActionDelegate.

In addition, the undo functionality had to be implemented separately. When the 
changes are performed, they (surprisingly) also return the undo changes that are 
needed by the UndoManager. The UndoManager is available through 
\textit{RefactoringCore.getUndoManager()}. See \textit{ToggleRefactoringRunner} 
for more details on the implementation.

\section{Testing and Performance}

This section introduces special tricks that were used to simplify testing and
control performance.

\subsection{Fuzzy whitespace recognition for the test environment}

As described in past theses at HSR, the refactoring testing environment
needed an exact definition of the generated code. This was annoying because
same-looking code samples could result in a red bar if white spaces were not the
same. To make writing new tests easier, the comparison method was overridden to
support fuzzy whitespace recognition.

Leading tabs or whitespaces are recognized and it is assumed that the same
indention is used for the whole file. In addition, trailing newlines that are
added by the ASTRewriter are ignored.

The changes made to the CDT test environment help writing new tests without
having to care whether the ASTRewriter uses spaces or tabs for indention.
Resulting code that looks the same now gives a green bar.

\subsection{Performance tests}

Performance was tested using the org.eclipse.test.performance plugin. Four
different scenarios have been chosen for comparison:

\begin{enumerate}
\item testWithIncludeStatements()
\item testWithoutIncludeStatements()
\item testInClassToInHeader()
\item testInHeaderToInClass()
\end{enumerate}

In addition, an all-together test has been included for quick performance
comparison and a reference test that did nothing was run to measure the overhead
of the performance test framework. Since in reality the refactorings are slower
than the (repeated) measurements, resulting values should be considered relative
to each other. The same developer laptop was used for before and after tests.

\begin{tabular}[t]{l|rrr}
 Scenario   & first draft & final result & improvement in \% \\
 \hline
 Scenario 1	&  364ms & --ms & --\% \\
 Scenario 2	&  337ms & --ms & --\% \\
 Scenario 3	&  335ms & --ms & --\% \\
 Scenario 4	&  323ms & --ms & --\% \\
 All tests	& 5530ms & --ms & --\% \\
 Reference test	&    0ms & --ms & --\% \\
\end{tabular}

\subsection{Issues}

This section describes special cases that have been omitted intentionally or due 
to lack of time. In addition, found limitations of the CDT are described here.

\subsubsection{Constructor/Destructor bug}
\textbf{Problem}: Let CDT create a new class with a constructor and a destructor. 
Then toggle the constructor out of the class definition. The Destructor will be overridden partially. This problem only occurs in exactly this situation (no paramenters, no initialization lists).
\textbf{Cause}: Unknown. It seems to be some offset bug.
\textbf{Solution}: None yet.

\subsubsection{Menu integration}
\textbf{Problem}: Adding a new menu item to the refactor menu is difficult when 
developing a separate plugin.
\textbf{Cause}: Menu items are hardcoded inside 
\textit{CRefactoringActionGroup}. No way was found to replace or change this 
class within a separate plugin. In addition, the use of the 
\textit{org.eclipse.ui.actionSets} extension point does not make inserting new 
items easier.
\textbf{Solution}: The menu was added using \textit{plugin.xml} and may be added 
by the user manually. Right-click the toolbar, choose "Customize Perspective...", 
"Command Groups Availability" and check every group that is named "C++ Coding". 
This reveals the new menu item inside the refactor menu. Anyhow, the refactoring 
may always be invoked using the key binding.

The toggle key binding was realized using the \textit{org.eclipse.ui.bindings} 
extension point.

\subsubsection{The selection}
\textbf{Problem}: After toggling multiple times, the wrong functions were 
toggled or no selected function was found at all. 
\textbf{Cause}: The region provided by \textit{CRefactoring} pointed to a wrong 
code offset. 
\textbf{Solution}: The current selection is now based directly on the current 
active editor part's selection.

\subsubsection{Comments and macros}
\textbf{Problem}: Nodes inside a translation unit have to be copied to be 
changed since they are frozen. When nodes are copied, their surrounding comments 
get lost during rewrite. This was annoying, since copying the function body 
provided a straightforward solution for replacing a declaration with a 
definition.

Another issue were macros. Macros are working perfectly when copied and 
rewritten inside the same translation unit. As soon as a macro is moved outside 
to another translation unit, the macro will be expanded during rewrite. 

\textbf{Cause}: The rewriter is using a method in \texttt{ASTCommenter} to get a 
\texttt{NodeCommentMap} of the rewritten translation unit. If a node is copied, 
it has another reference which won't be inside the comment map anymore. Thus, 
when the rewriter writes the new node, it won't notice that the node was 
replaced by another.

\textbf{Solutions}:
\begin{itemize}
\item Get the raw signature of the code parts that should be copied and insert 
them using an ASTLiteralNode. 

Pro: It works without changing the CDT core and macros are not expanded. 

Contra: Breaks indentation and inserts unneeded newlines. This solution was used 
finally because whitespace issues may be dealt with the formatter.
\item Do as \texttt{ExtractFunction} does: rewrite each statement inside the 
function body separately. 

Pro: automatic indentation. 

Contra: touches the body although it does not need to be changed in any way. 
\item Change the CDT: Inside the \texttt{ChangeGenerator.generateChange}, the 
\texttt{NodeCommentMap} of the translation unit is fetched. By writing a patch, 
it was possible to insert new mappings into this map. This allowed to move 
comments of an old node to any newly created node. 

Pro: automatic indentation, developer may choose where to put the comments, 
every comment may be preserved. 

Contra: does not deal with macros, five classes need to be changed in CDT, 
comments need to be moved by hand. See the branch 'inject' inside the repository 
to study this solution.
\item Find and insert comments by hand using an IASTComment. 

Pro: lets the developer decide where to put the comment. 

Contra: Feature is commented-out in the 7.0.1 release of CDT, comments need to 
be moved by hand.
\item Other solutions may be possible. An idea could be to register the comments 
during copy functions. This would require to change every copy function of every 
IASTNode. 
\end{itemize}

\subsubsection{Toggling function-local functions}
\textbf{Problem}: When function-local functions are allowed to be toggled, the 
fuzzy selection detection may not be as intuitive to the user as intended. If 
the cursor is inside a function body, the parent function definition should be 
toggled.

\textbf{Cause}: At least GCC allows to define functions inside a function, even 
templated or namespaced ones or ones that are inside a class definition. In the 
beginning, selection detection just found the nearest definition around the 
selection.

\textbf{Solution}: Function-local functions are skipped in favour of the next 
parent that is a declaration that may be toggled. If no parent is found, the 
refactoring aborts.

