\chapter{Specification}
\thispagestyle{fancy}

This section describes how the different code automation mechanisms have been
understood and designed.

\section{\textit{Toggle Function Definition}}

The idea: good code should separate interface and implementation. However, it is 
annoying to copy function signatures from the header file to the implementation 
file or vice versa. 

\textit{Toggle Function Definition} moves the code of a member function between 
different possible places, preserving the declaration statement inside the 
header file. What the different places are, in which direction the code may be 
moved and in which situation the refactoring may be invoked is described in the 
following chapters. 

\subsection{Examples}

\subsubsection{Toggle free function from .cpp to .h}
If \marginline{declaration exists} a separate declaration of the function exists,
the declaration shall be substituted by the definition. If the definition is 
placed inside a header file, its declaration shall remain there. This implies 
that when the following code 

\begin{lstlisting}[caption={A.h},label={01freefuncPre},language=C++]
#ifndef EXAMPLE_H
#define EXAMPLE_H

class ClearClass {
  void bigfunction() {
    /* implementation */
  }
};

#endif
\end{lstlisting}

is toggled twice, it will result in a declaration inside the header file.

What happens if no declaration is found? \marginline{no declaration}
Whenever a free function definition is toggled the first time, the whole 
definition shall be moved to a header file with the same name as the source 
file. When this definition is toggled back to the source file, the declaration will remain in
Whenever a free function is toggled, it shall swap definition and declaration. 
When toggling to the header file and no declaration may be found there, the 
definition will be created there.
with the same name as the source file
\begin{tabular}{p{5cm}p{.4cm}p{5cm}}
\begin{lstlisting}[caption={A.h},label={01freefuncPostCpp},language=C++]
void freefunction {
  return;
}
\end{lstlisting}
& & 
\begin{lstlisting}[caption={A.cpp},label={01freefuncPostH},language=C++]
#ifndef FREEFUNC_H_
#define FREEFUNC_H_

void freefunc() {
  return;
}

#endif
\end{lstlisting}
\end{tabular}

\subsection{Activation}

Most important is this basic rule: A function definition must exist.

The refactoring may be activated as soon as the user is editing a C++ 
translation unit and the cursor resides inside a function declaration or 
definition. For the selected function, a function definition must exist in an 
associated file. If no definition exists, the refactoring aborts. There may be 
more than one declaration. If more than one declaration is selected, it is not 
specified which one will be toggled.

The refactoring shall allow selections anywhere inside the function, be it 
inside the signature, function (try) body, catch handlers or template 
declarations. 

\subsection{Three positions for function definitions}

\label{positions}
In C++ there are three possible positions where a \marginline{\textit{in-class}}
function definition may occur. Listing \ref{classheaderimpl} shows an example
where the definition of a class member function is placed inside its class
definition. Placing implementation code right next to the declaration is the
most intuitive behaviour for Java developers. New code blocks created by
\textit{Implement Member Function} are placed inside the class definition too.

\lstinputlisting[caption={In Class implementation in A.h},
label={classheaderimpl}]{classheader_implementation.h}

%TODO: add a footnote for the 'extern' problem. (MS, 2.12.2010)
To keep the interface clear, \marginline{\textit{in-header}} functions may be 
placed outside the class definition but still in the same (header) file. Such a 
function is called \textit{inlined}. For templates, this is the only position 
where implementation may be placed outside the class definition due to problems 
of the \textit{extern} keyword. Templated functions cannot be placed outside the 
header file. Except for ... %TODO: find cases where template functions can be
%placed outside of a header file
The following listings show an example of what will be called 
\textit{in-header situation} throughout this document.

\lstinputlisting[caption={Implementation outside of the class in A.h},
label={outsideclass}]{outside_class_implementation.h}

To \marginline{\textit{in-file}} separate implementation from the interface more 
clearly, a separate source file may be used for the definitions while the 
declarations remain in the header file. An example for this position of a 
function definition is shown by listings \ref{twofilesolution_header} and
\ref{twofilesolution_impl}. The position will be called 
\textit{in-implementation} or \textit{in-file}.

\vspace{0.5cm}
\begin{minipage}{.48\textwidth}
\lstset{xrightmargin=0.5cm}
\begin{lstlisting}[caption={A.h},label={twofilesolution_header},language=C++]
#ifndef A_H_
#define A_H_

class A {
	int x();
};

#endif /* _A_H */
\end{lstlisting}
\end{minipage}%
\begin{minipage}{.48\textwidth}
\lstset{xleftmargin=0.5cm}
\begin{lstlisting}[caption={A.cpp},label={twofilesolution_impl},language=C++]
#include "A.h"

int A::x() { 
    /* impl. */ 
}
\end{lstlisting}
\end{minipage}

\subsection{Basic scenarios}

Depending on the current selections, different strategies need to be applied to 
move the function definition. All supported toggling situations and their 
special cases are listed in this chapter.

\subsubsection{Free functions}
For plain free functions, toggling shall happen between two positions:
\begin{enumerate}
\item Toggle from in-header to in-file
\item Toggle from in-file to in-header
\end{enumerate}

\subsubsection{Member functions}
For functions inside classes, toggling is expected to be available for three 
positions:
\begin{enumerate}
\item Toggle from in-class to in-header
\item Toggle from in-header to in-file
\item Toggle from in-file to in-class
\end{enumerate}

\subsection{Special cases}

Not every function may be toggled between the three positions and some cases 
require additional work before they may be toggled. Those special case are 
listed in this section.

\subsubsection{Namespaces}

If the moved function definition is contained inside a namespace definition, a 
new namespace definition shall be created. The function is then inserted into 
the newly created namespace definition.

Contrariwise, namespace definitions that would become empty after removing the 
last function shall be deleted.

\subsubsection{Templated member functions}

An exception are templated member functions that may only be toggled inside the 
same header file.
\begin{enumerate}
\item Toggle from in-class to in-header
\item Toggle from in-header to in-class
\end{enumerate}

\section{\textit{Implement Member Function}}

\subsection{Activation}
This refactoring shall be active as soon as a function declaration is selected 
that has no associated definition. A missing semicolon at the end of the 
function declaration should not stop the mechanism to work.

After writing a function declaration in the class definition, not yet written
the ``;'', code completion can be used to create the function body with an
appropriate default empty return statement.\newline

An already completed function declaration can be transformed to a function
definition by using the ``Implement Member Function'' hot-key which creates a
body with default empty return statement.

\subsection{Expected result}
As described above, functions may only be toggled when they provide a function 
body. This refactoring shall provide a facility to create an empty function body 
with a default return value to enable \textit{Toggle Function Definition}.

The re-implementation of \textit{implement function} must be very fast. 

\section{Override virtual member function}

No deeper investigation has been done for this refactoring since it was not 
implemented during the project.

