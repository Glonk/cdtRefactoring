\chapter{Specification}
\thispagestyle{fancy}

This section describes how the different code automation mechanisms have been
understood and designed.

\section{\textit{Toggle Function Definition}}

The idea: good code should separate interface and implementation. However, it is 
annoying to copy function signatures from the header file to the implementation 
file or vice versa. 

\textit{Toggle Function Definition} moves the code of a member function between 
different possible places, preserving the declaration statement inside the 
header file. What the different places are and in which direction the code may 
be moved is described in the following chapters. 

\subsection{Three ways to implement a member function}

In C++ there are three possible positions where a \marginline{\textit{in-class}}
function definition may occur. Listing \ref{classheaderimpl} shows an example
where the definition of a class member function is placed inside its class
definition. Placing implementation code right next to the declaration is the
most intuitive behaviour for Java developers. New code blocks created by
\textit{Implement Member Function} are placed inside the class definition too.

\lstinputlisting[caption={In Class implementation in A.h},
label={classheaderimpl}]{classheader_implementation.h}

%TODO: add a footnote for the 'extern' problem. (MS, 2.12.2010)
The most common position \marginline{\textit{in-header}} for ``templated``
member functions is described by listing \ref{outsideclass}. Due to the problem
of the \texttt{extern} keyword, the definition must stay in the header
file.

\lstinputlisting[caption={Implementation outside of the class in A.h},
label={outsideclass}]{outside_class_implementation.h}

To avoid changing header files, \marginline{\textit{in-file}} it is common to
write implementation code inside a separate .cpp file. This third position of a
member function definition is shown by listings \ref{twofilesolution_header} and
\ref{twofilesolution_impl}.

\begin{tabular}{p{5cm}p{.4cm}p{5cm}}
\lstinputlisting[caption={A.h},
label={twofilesolution_header}]{implementation_file.h}
& & 
\lstinputlisting[caption={A.cpp},
label={twofilesolution_impl}]{implementation_file.c}
\end{tabular}

\subsection{How it works}

Depending on the current selections, different strategies need to be applied to 
move the function definition. All supported toggling Situations and their 
special cases are listed in this chapter.

\subsubsection{Toggling free functions}
may be templated or namespaced and may be placed inside a cpp or a header file.

\subsubsection{Toggling member functions}

\textit{Toggle Function Definition} is used to move the implementation of a 
member function between the positions described above. For a non-templated 
member function, moving is done in the following order:

\begin{itemize}
 \item From inside of the class definition (header file)
 \item to outside of the class in the same header file, using the
\textit{inline} keyword
 \item to a separate \textit{.cpp} file
 \item and back into the class definition / header file.
\end{itemize}

\subsubsection{Toggling templated member functions}

Templated member functions \marginline{templates} usually cannot be placed into
a separate file due to compiler restrictions. In case of a templated member
function, the implementation is therefore only moved between the first two
positions described.

Switching from the \textit{in-class} to the \textit{in-file} position directly
is not given a separate name nor key binding. Fast switching should make a
separate mechanism redundant. 

The active editor \marginline{editor} stays inside the same file after any of
the described moves.

\section{Re-Implementation of \textit{Implement Member Function}}

\subsection{The need for a new \textit{Implement Member Function}}

The current CDT plug-in already includes a \textit{Implement Member Function}.
However, it is slow and does not fit together with the \textit{Move
Implementation}. It breaks the coding flow for adding functionality to classes
twice, which could be a reason not to use the toggle key. Therefore, toggle key
will be supported by a new \textit{Implement Member Function} which achieves
synergy with the toggle key.

\subsection{How it works}
After writing a function declaration in the class definition, not yet written
the ``;'', code completion can be used to create the function body with a
appropriated default empty return statement.\newline

An already completed function declaration can be transformed to a function
definition by using the ``Implement Member Function'' hot-key which creates a
body with default empty return statement.

\section{Override virtual member function}
