\chapter{Specification}
\thispagestyle{fancy}

This section describes how the different code automation mechanisms have been
understood and designed.

\section{\textit{Toggle Function Definition}}

The idea: good code should separate interface and implementation. However, it is 
annoying to copy function signatures from the header file to the implementation 
file or vice versa. 

\textit{Toggle Function Definition} moves the code of a member function between 
different possible places, preserving the declaration statement inside the 
header file. What the different places are, in which direction the code may be 
moved and in which situation the refactoring may be invoked is described in the 
following chapters. 

\subsection{Activation}

Most important is this basic rule: A function definition must exist.

The refactoring may be activated as soon as the user is editing a C++ 
translation unit and the cursor resides inside a function declaration or 
definition. For the selected function, a function definition must exist in an 
associated file. If no definition exists, the refactoring aborts. There may be 
more than one declaration. If more than one declaration is selected, it is not 
specified which one will be toggled.

The refactoring should allow selections anywhere inside the function, be it 
inside the signature, function (try) body, catch handlers or template 
declarations. If functions are defined inside a function body which is 
non-standard but allowed for some compilers, the outermost function parent 
should be toggled.
% TODO: This is not the case yet

\subsection{Three positions for function definitions}

In C++ there are three possible positions where a \marginline{\textit{in-class}}
function definition may occur. Listing \ref{classheaderimpl} shows an example
where the definition of a class member function is placed inside its class
definition. Placing implementation code right next to the declaration is the
most intuitive behaviour for Java developers. New code blocks created by
\textit{Implement Member Function} are placed inside the class definition too.

\lstinputlisting[caption={In Class implementation in A.h},
label={classheaderimpl}]{classheader_implementation.h}

%TODO: add a footnote for the 'extern' problem. (MS, 2.12.2010)
To keep the interface clear, \marginline{\textit{in-header}} functions may be 
placed outside the class definition but still in the same (header) file. Such a 
function is called \textit{inlined}. For templates, this is the only position 
where implementation may be placed outside the class definition due to problems 
of the \textit{extern} keyword. Templated functions cannot be placed outside the 
header file. The following listings show an example of what will be called 
\textit{in-header situation} throughout this document.

\lstinputlisting[caption={Implementation outside of the class in A.h},
label={outsideclass}]{outside_class_implementation.h}

To \marginline{\textit{in-file}} separate implementation from the interface more 
clearly, a separate source file may be used for the definitions while the 
declarations remain in the header file. An example for this position of a 
function definition is shown by listings \ref{twofilesolution_header} and
\ref{twofilesolution_impl}. The position will be called 
\textit{in-implementation} or \textit{in-file}.

\begin{tabular}{p{5cm}p{.4cm}p{5cm}}
\lstinputlisting[caption={A.h},
label={twofilesolution_header}]{implementation_file.h}
& & 
\lstinputlisting[caption={A.cpp},
label={twofilesolution_impl}]{implementation_file.c}
\end{tabular}

\subsection{Basic scenarios}

Depending on the current selections, different strategies need to be applied to 
move the function definition. All supported toggling situations and their 
special cases are listed in this chapter.

\subsubsection{Free functions}
For plain free functions, toggling shall happen between two positions:
\begin{enumerate}
\item Toggle from in-header to in-file
\item Toggle from in-file to in-header
\end{enumerate}

\subsubsection{Member functions}
For functions inside classes, toggling is expected to be available for three 
positions:
\begin{enumerate}
\item Toggle from in-class to in-header
\item Toggle from in-header to in-file
\item Toggle from in-file to in-class
\end{enumerate}

\subsubsection{Templated member functions}
An exception are templated member functions that may only be toggled inside the 
same translation unit.
\begin{enumerate}
\item Toggle from in-class to in-header
\item Toggle from in-header to in-class
\end{enumerate}

\subsection{Special case - namespaces}

Empty namespaces shall be deleted when toggling removed the last function 
contained.

\section{\textit{Implement Member Function}}

\subsection{Activation}
This refactoring shall be active as soon as a function declaration is selected 
that has no associated definition. A missing semicolon at the end of the 
function declaration should not stop the mechanism to work.

After writing a function declaration in the class definition, not yet written
the ``;'', code completion can be used to create the function body with a
appropriated default empty return statement.\newline

An already completed function declaration can be transformed to a function
definition by using the ``Implement Member Function'' hot-key which creates a
body with default empty return statement.

\subsection{Expected result}
As described above, functions may only be toggled when they provide a function 
body. This refactoring shall provide a facility to create an empty function body 
with a default return value to enable \textit{Toggle Function Definition}.

The re-implementation of \textit{implement function} must be very fast. 

\section{Override virtual member function}

No deeper investigation has been done for this refactoring since it was not 
implemented during the project.

