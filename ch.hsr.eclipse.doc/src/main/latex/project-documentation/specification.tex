\chapter{Specification}
\thispagestyle{fancy}

This section describes how the different code automation mechanisms have been
understood and designed.

\section{\textit{Toggle Function Definition}}

The idea: good code should separate interface and implementation. However, it is 
annoying to copy function signatures from the header file to the implementation 
file or vice versa. 

\textit{Toggle Function Definition} moves the code of a member function between 
different possible places, preserving the declaration statement inside the 
header file. What the different places are, in which direction the code may be 
moved and in which situation the refactoring may be invoked is described in the 
following chapters. 

\subsection{Examples}

\subsubsection{Toggle free function from .cpp to .h}
Let assume a free function in a header file with no declaration specified
anywhere is toggled. Listing \nolinebreak\ref{01freefuncPre} shows the
situation before toggling. 

\begin{lstlisting}[caption={A.cpp},label={01freefuncPre},language=C++]
int freefunction() {
  return 42;
}

int main() {
  return 0;
}
\end{lstlisting}

First it is checked if a file named with the same name as the original
implementation file exists. If not, one is created with the appropriated
include guards. See Listing \nolinebreak\ref{02freefuncNewFile}.

\begin{lstlisting}[caption={Newly createdA.h}, label={02freefuncNewFile},
language=C++]
#ifndef A_H_
#define A_H_

#endif /* A_H_ */
\end{lstlisting}

The function \texttt{freefunction()} definition is now moved inside the header
file as shown in listing \nolinebreak\ref{02freefuncInsert}

\begin{lstlisting}[caption={Inserted freefunction in A.h},
label={02freefuncInsert}, language=C++]
#ifndef A_H_
#define A_H_

int freefunction() {
  return 42;
}

#endif /* A_H_ */
\end{lstlisting}

If toggled again, the declaration of \texttt{freefunction()} remains inside the
header file while the definition is written to implementation file and an
include statement is inserted at the top of the implemtation file. Listing
\nolinebreak\ref{03freefuncEnd} and \ref{04freefuncEnd} shows the end
situation.

\begin{lstlisting}[caption={Inserted freefunction in A.h},
label={03freefuncEnd}, language=C++]
#ifndef A_H_
#define A_H_

int freefunction();

#endif /* A_H_ */
\end{lstlisting}

\begin{lstlisting}[caption={A.cpp},label={04freefuncEnd},language=C++]
#include "A.h"

int freefunction() {
  return 42;
}

int main() {
  return 0;
}
\end{lstlisting}

\subsection{Three positions for function definitions}

\label{positions}
In C++ there are three possible positions where a \marginline{\textit{in-class}}
function definition may occur. Listing \ref{classheaderimpl} shows an example
where the definition of a class member function is placed inside its class
definition. Placing implementation code right next to the declaration is the
most intuitive behaviour for Java developers. New code blocks created by
\textit{Implement Member Function} are placed inside the class definition too.

\lstinputlisting[caption={In Class implementation in A.h},
label={classheaderimpl}]{classheader_implementation.h}

%TODO: add a footnote for the 'extern' problem. (MS, 2.12.2010)
To keep the interface clear, \marginline{\textit{in-header}} functions may be 
placed outside the class definition but still in the same (header) file. Such a 
function is called \textit{inlined}. For templates, this is the only position 
where implementation may be placed outside the class definition due to problems 
of the \textit{extern} keyword. Templated functions cannot be placed outside the 
header file. Except for ... %TODO: find cases where template functions can be
%placed outside of a header file
The following listings show an example of what will be called 
\textit{in-header situation} throughout this document.

\lstinputlisting[caption={Implementation outside of the class in A.h},
label={outsideclass}]{outside_class_implementation.h}

To \marginline{\textit{in-file}} separate implementation from the interface more 
clearly, a separate source file may be used for the definitions while the 
declarations remain in the header file. An example for this position of a 
function definition is shown by listings \ref{twofilesolution_header} and
\ref{twofilesolution_impl}. The position will be called 
\textit{in-implementation} or \textit{in-file}.

\begin{tabular}{p{5cm}p{.4cm}p{5cm}}
\lstinputlisting[caption={A.h},
label={twofilesolution_header}]{implementation_file.h}
& & 
\lstinputlisting[caption={A.cpp},
label={twofilesolution_impl}]{implementation_file.cpp}
\end{tabular}

\subsection{Basic scenarios}

Depending on the current selections, different strategies need to be applied to 
move the function definition. All supported toggling situations and their 
special cases are listed in this chapter.

\subsubsection{Free functions}
For plain free functions, toggling shall happen between two positions:
\begin{enumerate}
\item Toggle from in-header to in-file
\item Toggle from in-file to in-header
\end{enumerate}

\subsubsection{Member functions}
For functions inside classes, toggling is expected to be available for three 
positions:
\begin{enumerate}
\item Toggle from in-class to in-header
\item Toggle from in-header to in-file
\item Toggle from in-file to in-class
\end{enumerate}

\subsection{Special cases}

Not every function may be toggled between the three positions and some cases 
require additional work before they may be toggled. Those special case are 
listed in this section.

\subsubsection{Namespaces}

If the moved function definition is contained inside a namespace definition, a 
new namespace definition shall be created. The function is then inserted into 
the newly created namespace definition.

Contrariwise, namespace definitions that would become empty after removing the 
last function shall be deleted.

\subsubsection{Templated member functions}

An exception are templated member functions that may only be toggled inside the 
same header file.
\begin{enumerate}
\item Toggle from in-class to in-header
\item Toggle from in-header to in-class
\end{enumerate}

\section{\textit{Implement Member Function}}

\subsection{Activation}
This refactoring shall be active as soon as a function declaration is selected 
that has no associated definition. A missing semicolon at the end of the 
function declaration should not stop the mechanism to work.

After writing a function declaration in the class definition, not yet written
the ``;'', code completion can be used to create the function body with an
appropriate default empty return statement.\newline

An already completed function declaration can be transformed to a function
definition by using the ``Implement Member Function'' hot-key which creates a
body with default empty return statement.

\subsection{Expected result}
As described above, functions may only be toggled when they provide a function 
body. This refactoring shall provide a facility to create an empty function body 
with a default return value to enable \textit{Toggle Function Definition}.

The re-implementation of \textit{implement function} must be very fast. 

\section{Override virtual member function}

No deeper investigation has been done for this refactoring since it was not 
implemented during the project.

