\chapter{Specification}
\thispagestyle{fancy}

This section describes how the different code automation mechanisms have been
understood and designed.

\section{Toggle Function Definition}

The idea: good code should separate interface and implementation. However, it is 
annoying to copy function signatures from the header file to the implementation 
file or vice versa. 

\textit{Toggle Function Definition} moves the code of a member function between 
different possible places, preserving the declaration statement inside the 
header file. What the different places are, in which direction the code may be 
moved and in which situation the refactoring may be invoked is described in the 
following chapters. 

\subsection{Examples}

\subsubsection{Toggle free function from .cpp to .h}
Let assume a free function in a header file with no declaration specified is
toggled. Listing \nolinebreak\ref{01freefuncPre} shows the situation before
toggling. 

\begin{lstlisting}[caption={A.cpp},label={01freefuncPre},language=C++]
int freefunction() {
  return 42;
}

int main() {
  return 0;
}
\end{lstlisting}

First it is checked if a file named with the same name as the original
implementation file exists. If not, a new file is created with the
appropriate include guards. See listing \nolinebreak\ref{02freefuncNewFile}.

\begin{lstlisting}[caption={Newly created A.h}, label={02freefuncNewFile},
language=C++]
#ifndef A_H_
#define A_H_

#endif /* A_H_ */
\end{lstlisting}

The \texttt{freefunction()} definition is now moved into the header
file as shown in listing \nolinebreak\ref{02freefuncInsert}

\begin{lstlisting}[caption={Inserted \texttt{freefunction()} in A.h},
label={02freefuncInsert}, language=C++]
#ifndef A_H_
#define A_H_

int freefunction() {
  return 42;
}

#endif /* A_H_ */
\end{lstlisting}

If toggled again, the declaration of \texttt{freefunction()} remains inside the
header file while the definition is inserted into the implementation file and an
include statement is prepended to the top of the implemtation file. Listing
\nolinebreak\ref{03freefuncEnd} and \ref{04freefuncEnd} shows the end
situation.

\vspace{0.5cm}
\begin{minipage}{.48\textwidth}
\lstset{xrightmargin=0.5cm}
\begin{lstlisting}[caption={Inserted freefunction in A.h},
label={03freefuncEnd}, language=C++]
#ifndef A_H_
#define A_H_

int freefunction();

#endif /* A_H_ */
\end{lstlisting}
\end{minipage}%
\begin{minipage}{.48\textwidth}
\lstset{xleftmargin=0.5cm}
\begin{lstlisting}[caption={A.cpp},label={04freefuncEnd},language=C++]
#include "A.h"

int freefunction() {
  return 42;
}

int main() {
  return 0;
}
\end{lstlisting}
\end{minipage}

If \texttt{freefunction()} is toggled again, the declaration in the header file
has to be replaced by the definition which is moved from the implementation
file, resulting in a header file already shown in listing
\nolinebreak\ref{02freefuncInsert}.

\subsubsection{Toggle Member Functions}

The starting point for toggling member functions can be for instance a class
with a function definition inside like in listing
\nolinebreak\ref{01toggleMemberFunction}.

\begin{lstlisting}[caption={A.h, function definition inside class declaration},
label={01toggleMemberFunction}, language=C++]
#ifndef A_H_
#define A_H_

namespace N {
class A {
  void foo() {
    return;
  }
};
}
#endif /* A_H_ */
\end{lstlisting}

Function \texttt{foo()} needs to be toggled. The next position of the
definition is ouside of the class but it is keept it in namespace level. At the
position the definition was, a declaration is inserted as in listing
\ref{02toggleMemberFunction}

If there is no namespace, the function definition will be placed below the
class in the header file. Listing \ref{02_1toggleMemberFunction}

If there are any special keywords like \texttt{virtual} or \texttt{static},
these are adapted to the new definition. Definitions in the header file need
the keyword \texttt{inline} prepended. The keyword \texttt{virtual}
is only allowed in inside a class definition. Furthermore for the
\textit{in-header} position the \texttt{inline} keyword needs to be prepended to
the function definition.

\begin{lstlisting}[caption={A.h,
function definition outside class
definition in header}, label={02toggleMemberFunction}, language=C++]
#ifndef A_H_
#define A_H_

namespace N {
class A {
  void foo();
};

inline void foo() {
  return;
}
}
#endif /* A_H_ */
\end{lstlisting}

\begin{lstlisting}[caption={A.h,
function definition outside class definition without namespace},
label={02_1toggleMemberFunction}, language=C++]
#ifndef A_H_
#define A_H_

class A {
  void foo();
};

inline void foo() {
  return;
}

#endif /* A_H_ */
\end{lstlisting}

If \texttt{foo()} gets toggled again, the definition is moved to the
implementation file and if necessary a namespace definition is created where
the function gets inserted. Nothing stays outside of the class definition in the
header file and the declaration in the class does not change.

\vspace{0.5cm}
\begin{minipage}{.48\textwidth}
\lstset{xrightmargin=0.5cm}
\begin{lstlisting}[caption={A.h, after moved definition},
label={03toggleMemberFunction}, language=C++]
#ifndef A_H_
#define A_H_

namespace N {
class A {
  void foo();
};
}

#endif /* A_H_ */
\end{lstlisting}
\end{minipage}%
\begin{minipage}{.48\textwidth}
\lstset{xleftmargin=0.5cm}
\begin{lstlisting}[caption={A.cpp with definition},
label={03_1toggleMemberFunction}, language=C++ ]
#include "A.h"

namespace N {
void A::foo() {
  return
}
}
\end{lstlisting}
\end{minipage}

If \texttt{foo()} is toggled once again, we reached the original starting
position we have seen in listing \ref{01toggleMemberFunction}. An empty
namespace in a implementation file will be removed.

\subsubsection{Toggle Templated Member Functions}

\subsection{Three positions for function definitions}

\label{positions}
In C++ there are three possible positions where a \marginline{\textit{in-class}}
function definition may occur. Listing \ref{classheaderimpl} shows an example
where the definition of a class member function is placed inside its class
definition. Placing implementation code right next to the declaration is the
most intuitive behaviour for Java developers. New code blocks created by
\textit{Implement Member Function} are placed inside the class definition too.

\begin{lstlisting}[caption={In-class implementation in A.h},
label={classheaderimpl}, language=C++ ]
#ifndef A_H_
#define A_H_

namespace N {
class A {
  int x() {
    return 0;
  }
};
}
\end{lstlisting}

%TODO: add a footnote for the 'extern' problem. (MS, 2.12.2010)
To keep the interface clear, \marginline{\textit{in-header}} functions may be 
placed outside the class definition but still in the same (header) file. Such a 
function is called \textit{inlined}. See Listing \ref{inheaderimpl}. For
templates, this is the only position where implementation may be placed outside
the class definition due to problems of the \texttt{extern} keyword. Templated
functions cannot be placed outside the header file. Except for ... 
%TODO: find cases where template functions can be
%placed outside of a header file
The following listings show an example of what will be called 
\textit{in-header situation} throughout this document.

\begin{lstlisting}[caption={In-header implementation in A.h},
label={inheaderimpl}, language=C++ ]
#ifndef A_H_
#define A_H_

namespace N {
class A {
  int x();
};

inline int A::x() {
  return 0;
}

}
\end{lstlisting}

To \marginline{\textit{in-file}} separate implementation from the interface more 
clearly, a separate source file may be used for the definitions while the 
declarations remain in the header file. An example for this position of a 
function definition is shown by listings \ref{twofilesolution_header} and
\ref{twofilesolution_impl}. The position will be called 
\textit{in-implementation} or \textit{in-file}.

\vspace{0.5cm}
\begin{minipage}{.48\textwidth}
\lstset{xrightmargin=0.5cm}
\begin{lstlisting}[caption={A.h},label={twofilesolution_header},language=C++]
#ifndef A_H_
#define A_H_

namespace N {
class A {
  int x();
};
}

#endif /* _A_H */
\end{lstlisting}
\end{minipage}%
\begin{minipage}{.48\textwidth}
\lstset{xleftmargin=0.5cm}
\begin{lstlisting}[caption={A.cpp},label={twofilesolution_impl},language=C++]
#include "A.h"

namespace N {
int A::x() { 
  return 0;
}
}
\end{lstlisting}
\end{minipage}

\subsection{Basic scenarios}

Depending on the current selections, different strategies need to be applied to 
move the function definition. All supported toggling situations and their 
special cases are listed in this chapter.

\subsubsection{Free functions}
For plain free functions, toggling shall happen between two positions:
\begin{enumerate}
\item Toggle from in-header to in-file
\item Toggle from in-file to in-header
\end{enumerate}

\subsubsection{Member functions}
For functions inside classes, toggling is expected to be available for three 
positions:
\begin{enumerate}
\item Toggle from in-class to in-header
\item Toggle from in-header to in-file
\item Toggle from in-file to in-class
\end{enumerate}

\subsection{Special cases}

Not every function may be toggled between the three positions and some cases 
require additional work before they may be toggled. Those special case are 
listed in this section.

\subsubsection{Namespaces}

If the moved function definition is contained inside a namespace definition, a 
new namespace definition shall be created. The function is then inserted into 
the newly created namespace definition.

Contrariwise, namespace definitions that would become empty after removing the 
last function shall be deleted.

\subsubsection{Templated member functions}

An exception are templated member functions that may only be toggled inside the 
same header file.
\begin{enumerate}
\item Toggle from in-class to in-header
\item Toggle from in-header to in-class
\end{enumerate}

\section{Implement Member Function}

\subsection{Activation}
This refactoring shall be active as soon as a function declaration is selected 
that has no associated definition. A missing semicolon at the end of the 
function declaration should not stop the mechanism to work.

After writing a function declaration in the class definition, not yet written
the ``;'', code completion can be used to create the function body with an
appropriate default empty return statement.\newline

An already completed function declaration can be transformed to a function
definition by using the ``Implement Member Function'' hot-key which creates a
body with default empty return statement.

\subsection{Expected result}
As described above, functions may only be toggled when they provide a function 
body. This refactoring shall provide a facility to create an empty function body 
with a default return value to enable \textit{Toggle Function Definition}.

The re-implementation of \textit{implement function} must be very fast. 

\section{Override virtual member function}

No deeper investigation has been done for this refactoring since it was not 
implemented during the project.

