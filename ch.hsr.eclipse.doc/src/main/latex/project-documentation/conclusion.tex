\chapter{Conclusions and future work}
\thispagestyle{fancy}

During the project, a lot of challenges have been discovered. They will be 
documented in the following sections along with a look back on the whole project 
and an outlook on what could be done in further theses. 

\section{Conclusions}

\subsection{\textit{Toggle Function Definition}}
The main goal of the project was to create a stable refactoring that would have 
a chance to be integrated into CDT. In the view of the authors, the developed 
plugin became quite handy but should be tested by a larger community before it 
may be released to the public. One drawback is that whitespaces are not handled 
satisfactorily.

Anyhow, it should be taken into account that the C++ language specification (and 
its implementations inside different compilers) may offer a lot more features 
than two programmers could ever think of. The fact that it is allowed to toggle 
even if there are syntax errors in the code makes it hard to test for every 
possible case. It is not sure whether the covered special cases are enough 
general to cover all language constructs, exotic or not, that may exist. Even 
programming against the C++ language specification is no guarantee that the 
refactoring will behave correctly out in the wild.

All in all, the developer team is proud of the solution although aware of the 
fact that there may still be some improvements needed to satisfy a large 
audience.

\subsection{Implement Function}
\textit{Implement Function} shares a lot of similarities and benefits of
functionality developed for the \textit{Toggle Function Definition}.


\subsection{Override Virtual Function}
No deeper investigation on how this refactoring could benefit from the developed 
work has been done until now.
% TODO: complete this chapter

\section{Known issues}

\subsection{Handling newly created files}
%TODO: think about droping this subsection
\textbf{Problem}: It is difficult do manipulate newly created files.
\textbf{Cause}: --
\textbf{Solution}: --

\subsection{Constructor / destructor bug}
\textbf{Problem}: Let CDT create a new class with a constructor and a destructor. 
Then toggle the constructor out of the class definition. The Destructor will be 
overridden partially. This problem only occurs in exactly this situation (no 
parameters, no initialization lists).
\textbf{Cause}: Unknown. It seems to be some offset bug.
\textbf{Solution}: None yet solved.

\subsection{Unneccessary newlines}
\textbf{Problem}: When toggling multiple times, a lot of newlines are generated 
by the rewriter. 
\textbf{Cause}: Newlines are inserted by the rewriter before and after an new
node but are not removed when removing the same node. To be able to judge how 
many newlines have to be inserted or removed, the whitespace situation around an 
affected node has to be analyzed thoroughly. Given figure \ref{commentA} it 
could be tried to always remove one newline before and one newline after the 
removed function.

\begin{figure}[h]
\begin{lstlisting}[language=C++]
void before() {
}
// 1st newline added
void newFunction() {
} // 2nd newline added

void after() {
}
\end{lstlisting}
\setlength{\abovecaptionskip}{-20pt}
\caption{Whitespaces may not be removed blindly}
\label{commentA}
\end{figure}

Yet, it is not determined whether the programmer changed the code to look like 
in figure \ref{commentB}. There, it would be fatal to remove a character before 
and after the function because brackets would be removed instead.

\begin{figure}[h]
\begin{lstlisting}[language=C++]
void before(){}void newFunction(){}void after(){}
\end{lstlisting}
\setlength{\abovecaptionskip}{-20pt}
\caption{the same code without the usual newlines}
\label{commentB}
\end{figure}

\textbf{Workaround}: First, the formatter could be used to remove multiple 
newlines. This breaks the programmers formatting which could be disruptive. 
Another solution is to manually change the generated text edits to avoid 
inserting or to delete more newlines. However, the changes are highly coupled to 
the different refactoring strategies. When this solution was tried to be 
implemented, it was a problem too that the generated text edits were changing 
their array positions, which made changes even more difficult. The resulting 
code was unstable and this solution is not recommended. 

\subsection{Comment handling}
\textbf{Problem}: A lot of freestanding comments are generated when
toggling multiple times. These comments become leading if a function gets
toggled below these freestanding comments.
\textbf{Cause}: When a node is removed by the rewriter, associated comments are 
not removed. This may be seen as a defensive strategy to avoid deleting comments 
accidentally. The ASTRewrite adopts all comments above a node as an leading
comment not caring how many spaces or lines they have in between.

\subsection{Menu integration (partially solved)}
\textbf{Problem}: Adding a new menu item to the refactor menu is difficult when 
developing a separate plugin.
\textbf{Cause}: Menu items are hardcoded inside 
\textit{CRefactoringActionGroup}. No way was found to replace or change this 
class within a separate plugin. In addition, the use of the 
\textit{org.eclipse.ui.actionSets} extension point does not make inserting new 
items easier.
\textbf{Workaround}: The menu was added using \textit{plugin.xml} and may be added 
by the user manually. See the manual in \ref{cmdGroup} to solve this issue. 
Anyhow, the refactoring may always be invoked using the key binding. 

\subsection{Preprocessor Statements}
\textbf{Problem}: If a preprocessor statement (\textit{\#ifdef}) is contained in
the parent of a rewritten, removed or inserted node, the preprocessor statement
is deleted.
\textbf{Cause:}: The rewriter does not support preprocessor statements.
\textbf{Solution}: None yet. This has to be solved by a fix for the rewriter
which supports preprocessor statements.

There was a small work around for this problem by warning about the presence of
a preprocessor statement in the affected files. At the end this was dropped
because this breaks the initial idea of the code flow.

\section{Solved issues}

This section describes special cases that have been omitted intentionally or due 
to lack of time. In addition, found limitations of the CDT are described here.

\subsection{Speed}
\textbf{Problem}: Refactoring, especially the first run, was very slow in the 
beginning. Including a big library slowed down the process even more.
\textbf{Cause}: The first thought was that header file indexing was the cause. 
However, the indexer option that skips already indexed headers is enabled in 
\textit{CRefactoring}. In the end, it was found out that most of the time was 
consumed by the \textit{checkInitialConditions} method of \textit{CRefactoring} 
that checked for problems inside the translation unit.
\textbf{Solution}: The super call to \textit{checkInitialConditions} was omitted.

\subsection{Accessing standalone header files}
\textbf{Problem}: Header files that are not included in any source file by 
default were not found by the indexer. Thus, it was not possible to analyze the 
source code of the affected header file.
\textbf{Cause}: By default, the indexer preference option 
\textit{IndexerPreferences.KEY\_INDEX\_UNUSED\_HEADERS\_WITH\_DEFAULT\_LANG} is 
set to false. However, this option is needed for standalone header files to be 
indexed.
\textbf{Solution}: Set the described option in \textit{IndexerPreferences} to 
true.

\subsection{Selection}
\textbf{Problem}: After toggling multiple times, the wrong functions were 
toggled or no selected function was found at all. 
\textbf{Cause}: The region provided by \textit{CRefactoring} pointed to a wrong 
code offset. This happens due to the fact that 
\textit{IWorkbenchWindowActionDelegate}'s \textit{selectionChanged} method is 
updated with outdated offset information.
\textbf{Solution}: The current selection is now based directly on the current 
active editor part's selection and fetched every time when toggling is started.

\subsection{Comments and macros}
\textbf{Problem}: Nodes inside a translation unit have to be copied to be 
changed since they are frozen. When nodes are copied, their surrounding comments 
get lost during rewrite\cite{Sommerlad:2008:RCR:1449814.1449817}. This was annoying, since copying the function body 
provided a straightforward solution for replacing a declaration with a 
definition.

Another issue were macros. Macros are working perfectly when copied and 
rewritten inside the same translation unit. As soon as a macro is moved outside 
to another translation unit, the macro will be expanded during rewrite or even
deleted when no information about the macro is found.

\textbf{Cause}: The rewriter is using a method in \texttt{ASTCommenter} to get a 
\texttt{NodeCommentMap} of the rewritten translation unit. If a node is copied, 
it has another reference which won't be inside the comment map anymore. Thus, 
when the rewriter writes the new node, it won't notice that the node was 
replaced by another.

\textbf{Solutions}:
\begin{itemize}
\item Get the raw signature of the code parts that should be copied and insert 
them using an ASTLiteralNode. 

Pro: It works without changing the CDT core and macros are not expanded. 

Contra: Breaks indentation and inserts unneeded newlines. This solution was used 
finally because whitespace issues may be dealt with the formatter.
\item Do as \texttt{ExtractFunction} does: rewrite each statement inside the 
function body separately. 

Pro: automatic indentation. 

Contra: touches the body although it does not need to be changed in any way. 
\item Change the CDT: Inside the \texttt{ChangeGenerator.generateChange}, the 
\texttt{NodeCommentMap} of the translation unit is fetched. By writing a patch, 
it was possible to insert new mappings into this map. This allowed to move 
comments of an old node to any newly created node. 

Pro: automatic indentation, developer may choose where to put the comments, 
every comment may be preserved. 

Contra: does not deal with macros, five classes need to be changed in CDT, 
comments need to be moved by hand. See the branch 'inject' inside the repository 
to study this solution.
\item Find and insert comments by hand using an IASTComment. 

Pro: lets the developer decide where to put the comment. 

Contra: Feature is commented-out in the 7.0.1 release of CDT, comments need to 
be moved by hand.
\item Other solutions may be possible. An idea could be to register the comments 
whenever a node is being copied. Since \textit{copy} is abstract in 
\textit{IASTNode} and implemented separately inside every node, this would 
require a change inside every node class.
\end{itemize}

\subsection{Toggling function-local functions}
\textbf{Problem}: When using function-local functions, the refactoring may 
produce code that won't compile.

\textbf{Cause}: Despite in the C++ standard\cite{IsoCpp} function-local 
functions are not allowed, the Gnu C Compiler allows to define such nested 
functions\cite{GCC}. In this case the selection detection finds the nested 
function if selected and it is tried to toggle it. However, it is not guaranteed 
that valid code will be generated.

\textbf{Solution}: Toggling is disabled for such nested function definitions.


\section{Further work}

The toggle refactoring was developed as a separate plugin so integration into 
the CDT project should be possible if desired.

It should be a small task to provide a solution for multi-toggling. If the user 
selects more than one definition, all of them could be toggled. An example 
workflow could be "Create new class (inherit from an abstract class)", "add 
unimplemented methods", "toggle all methods to an implementation file".

Support for preprocessor statements (fix the rewriter). Fix the rewriter to 
remove comments too.

A mechanism could be implemented that fixes indentation after refactoring.
Better user feedback in case of errors could be provided.

% TODO: Add a soul-stirring, deeply moving text about \textit{Override Virtual Member Function} and some more outlooks

