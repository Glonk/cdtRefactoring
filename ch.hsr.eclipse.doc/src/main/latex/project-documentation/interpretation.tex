\chapter{Interpretation}
\thispagestyle{fancy}

After implementation, a look back was made on what the resulting refactoring is 
capable of and what may still need some improvement.

\section{Features and limitations}

Toggling functions is available inside any class or namespace hierarchy and may 
be invoked when the selection is anywhere inside a function declaration or body. 
Basic templated functions are supported as well. However, there might be 
template special cases that were not thought of.

On the other side, the code generator removes preprocessor statements that stay 
inside a node that has to be rewritten. Removing comments of removed nodes was 
not achieved without changing the rewriter.

\section{Performance results}

It is difficult to compare the speed with other refactorings of CDT since wizards 
are used for the other known refactorings. However, the goal was reached that 
the refactoring is executing almost instantly.

It was planned to measure the speed of the jUnit tests. However, the displayed 
time does not represent the actual speed of the refactoring. This may be due to 
the fact that tests are not being invoked exactly the same way as the actual 
refactoring. 

The results from the \textit{org.eclipse.test.performance} speed tests were not 
used too. Since in reality the refactorings are much slower than the 
(repeated) measurements, resulting values may only be compared relative to each 
other.

In the end, the only way to judge whether the refactorings became quicker is to 
check out an older version like \textit{597440f4552eaa} and to try it out 
manually. Including dependencies like iostream slowed down the refactoring 
noticeably before speed was improved.

\section{Personal review}

Some words from the authors about the developed plugin, project management, of 
what was fun and what not.

\subsection{Martin Schwab}

What I like about the developed refactoring is that it was possible to implement 
it without a wizard. However, the user needs full trust in the code generation 
that it won't break code and this is currently not given when preprocessor 
statements are used. Nevertheless I'm glad the developed plugin is able to write 
complex template definitions that I couldn't write myself without the C++ 
specification by my side. This could save a lot of time.

What next? If the plugin is integrated into CDT, I'd be interested in the 
Eclipse Usage Data Collector
\footnote{\url{http://www.eclipse.org/org/usagedata/results.php}} to check 
whether users find out when and how they can profit from the refactoring and 
whether they use it repeatedly. If the refactoring is considered helpful by 
users and applied as it is designed to use, this should be reflected in a high 
execution count compared to the user count.

\subsection{Thomas Kallenberg}


\subsection{What we would do the same way}

Using Git\footnote{\url{http://www.kernel.org/pub/software/scm/git/}} for version 
control was very useful. The provided development server was occasionally down 
during the first weeks and it was possible to continue work locally. Being able 
to work locally was also helpful to work on the train. 

Working next to each other in the same study room was helpful to get quick 
answers for questions, reduce slow written communication and playing a round of 
table foot when concentration was used up.

For each meeting, the planned tasks were collected inside the agenda, then 
rubber-stamped by the supervisor and transformed into issues for the following 
week. This way, a minimal administrative overhead was produced.

\subsection{What we would not do the same way}

Time management: During most of the project, time was tracked for every issue. 
However, the collected data was not actively used to measure team velocity and 
estimate further issues. This valuable data could have been used for better 
scope prediction.

The default Redmine \textit{trackers} and \textit{categories} that were used 
were not sufficient to track time in a way that shiny charts could be produced 
for categories like ''implementation'', ''documentation'' and ''administration. 

The special cases that were listed on the project wiki were useful to 
communicate but it may have saved time if they were directly integrated into 
the documentation.

