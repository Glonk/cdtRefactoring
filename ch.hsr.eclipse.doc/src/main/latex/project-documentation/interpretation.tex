\chapter{Interpretation}
\thispagestyle{fancy}

After implementation, a look back was made on what the resulting refactoring is 
capable of and what may still need some improvement.

\section{Features and limitations}

Toggling functions is available inside any class or namespace hierarchy and may 
be invoked when the selection is anywhere inside a function declaration or body. 
Basic templated functions are supported as well. However, there might be 
template special cases that were not thought of.

On the other side, the code generator removes preprocessor statements that stay 
inside a node that has to be rewritten. Removing comments of removed nodes was 
not achieved without changing the rewriter.

\section{Performance results}

It is difficult to compare the speed with other refactorings of CDT since wizards 
are used for the other known refactorings. However, the goal was reached that 
the refactoring is executing almost instantly.

It was planned to measure the speed of the jUnit tests. However, the displayed 
time does not represent the actual speed of the refactoring. This may be due to 
the fact that tests are not being invoked exactly the same way as the actual 
refactoring.

The results from the \textit{org.eclipse.test.performance} speed tests were not 
used too. Since in reality the refactorings are much slower than the 
(repeated) measurements, resulting values may only be compared relative to each 
other.

In the end, the only way to judge whether the refactorings became quicker is to 
check out an older version like \textit{597440f4552eaa} and to try it out 
manually. Including dependencies like iostream slowed down the refactoring 
noticeably before speed was improved.

\section{Personal review}

Some words from the authors about the developed plugin, project management, of 
what was fun and what not.

\subsection{Martin Schwab}

What I like about the developed refactoring is that it was possible to implement 
it without a wizard. However, the user needs full trust in the code generation 
that it won't break code and this is currently not given when preprocessor 
statements are used. Nevertheless I'm glad the developed plugin is able to write 
complex template definitions that I couldn't write myself without the C++ 
specification by my side. This could save a lot of time.

What next? If the plugin is integrated into CDT, I'd be interested in the 
Eclipse Usage Data Collector
\footnote{\url{http://www.eclipse.org/org/usagedata/results.php}} to check 
whether users find out when and how they can profit from the refactoring and 
whether they use it repeatedly. If the refactoring is considered helpful by 
users and applied as it is designed to use, this should be reflected in a high 
execution count compared to the user count.

\subsection{Thomas Kallenberg}

Personally I like the C++ programming language. Despite the complexity it can
be an alternative to Java or other OOP languages. Specially if there is a focus
on performance or other subjects where templates do fit nicely in the concept
of the project.
The one touch toggle refactoring is another step towards a better knowledge of
C++.

What I liked about the project was the clear and productive communication with
the supervisor. The Environment to develop a CDT Refactoring provided enough
functionality to develop a good refactoring in the given time scope but let us
enough freedom to realize innovative ideas.

The goal was to develop a plugin that is used by the world an not thrown away.
Even if we could not solve all issues, specially with comments and macros, I
think we archived in the main task and realized our supervisors and customers 
idea of a toggle definition.

\subsection{What we would do the same way}

Using Git\footnote{\url{http://www.kernel.org/pub/software/scm/git/}} for version 
control was very useful. The provided development server was occasionally down 
during the first weeks and it was possible to continue work locally. Being able 
to work locally was also helpful to work on the train. 

Working next to each other in the same study room was helpful to get quick 
answers for questions, reduce slow written communication and playing a round of 
table foot when concentration was used up.

For each meeting, the planned tasks were collected inside the agenda, then 
rubber-stamped by the supervisor and transformed into issues for the following 
week. This way, a minimal administrative overhead was produced.

\subsection{What we would not do the same way}

\subsubsection{Time management}
During most of the project, time was tracked for every issue. 
However, the collected data was not actively used to measure team velocity and 
estimate further issues. This valuable data could have been used for better 
scope prediction.

\subsubsection{Redmine fine tuning}
The default Redmine \textit{trackers} and \textit{categories} that were used 
were not sufficient to track time in a way that shiny charts could be produced 
for categories like ''implementation'', ''documentation'' and ''administration. 

\subsubsection{Wiki and Documentation differences}
The special cases that were listed on the project wiki were useful to 
communicate but it may have saved time if they were directly integrated into 
the documentation.

\subsubsection{Multiple git branches}
While using one master git branch for every developer, a second git branch 
called development was introduced. During half a week new work was committed to the
development branch and then both trees were merged. The idea behind this was to
always have a stable master branch. This allowed to carelessly mess around
inside the development branch which resulted in nobody daring
to pull from the others branch. Inside the master branch everything was already merged and
the development branch was in an ``always unstable'' condition.
If something unstable is introduced to the repository one should use explicitly
a separate branch and include this in the master as soon as possible.

